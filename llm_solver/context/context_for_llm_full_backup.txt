================================================================================
BRKGA FRAMEWORK CONTEXT FOR CODE GENERATION
================================================================================

This document provides the essential patterns and requirements for generating
BRKGA configuration files that will compile and work correctly with the framework.

================================================================================
CRITICAL CONSTRUCTOR PATTERNS
================================================================================

The BRKGAConfig base class has TWO constructor forms:

1. SINGLE COMPONENT (most common):
   BRKGAConfig<T>(chromosome_length)

2. MULTI-COMPONENT:
   BRKGAConfig<T>({length1, length2, ...})

EXAMPLES:
✅ CORRECT:
   BRKGAConfig<T>(52)                                    // Single component, 52 genes
   BRKGAConfig<T>({static_cast<int>(w.size())})         // Single component with vector size
   BRKGAConfig<T>({50, 50})                             // Two components of 50 genes each

❌ WRONG:
   BRKGAConfig<T>(52, 1, 3)                             // NO! This constructor doesn't exist
   BRKGAConfig<T>(52, num_objectives, num_constraints)  // NO! Wrong signature

================================================================================
CRITICAL FUNCTION SIGNATURES
================================================================================

CRITICAL NVCC RULES:

1. When calling member functions, NEVER use "this->" prefix.
   NVCC error: "a pointer to a bound function may only be used to call the function"

   ✅ CORRECT:
   return calculate_fitness(individual);  // No "this->"
   if (chromosome_length() != expected) { }  // Call with ()

   ❌ WRONG:
   return this->calculate_fitness(individual);  // NVCC ERROR!
   if (this->chromosome_length != expected) { }  // NVCC ERROR! Missing () and has this->

2. Member FUNCTIONS must ALWAYS be called with parentheses ()

   ✅ CORRECT:
   int len = chromosome_length();  // Function call with ()

   ❌ WRONG:
   int len = this->chromosome_length;  // NVCC ERROR! Missing () and has this->
   int len = chromosome_length;  // NVCC ERROR! Missing ()

ALL problem-specific functions MUST use Individual<T>& NOT std::vector<T>&:

1. FITNESS FUNCTION:
   ✅ CORRECT:
   this->fitness_function = [this](const Individual<T>& individual) -> T {
       const auto& chromosome = individual.get_chromosome();
       // ... calculate fitness using chromosome
       return fitness_value;
   };

   ✅ CORRECT (calling helper methods):
   this->fitness_function = [this](const Individual<T>& individual) -> T {
       return calculate_fitness(individual);  // Call without "this->" prefix!
   };

   ❌ WRONG (explicit this-> when calling methods):
   this->fitness_function = [this](const Individual<T>& individual) -> T {
       return this->calculate_fitness(individual);  // NVCC ERROR! Don't use "this->"
   };

   ❌ WRONG (wrong signature):
   this->fitness_function = [this](const std::vector<T>& chromosome) -> T {
       // NO! Wrong signature
   };

2. DECODER:
   ✅ CORRECT:
   this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
       const auto& chromosome = individual.get_chromosome();
       // ... decode chromosome to solution
       return decoded_solution;
   };

   ✅ CORRECT (calling helper methods):
   this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
       return decode_to_solution(individual);  // Call without "this->" prefix!
   };

   ❌ WRONG (explicit this-> when calling methods):
   this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
       return this->decode_to_solution(individual);  // NVCC ERROR! Don't use "this->"
   };

   ❌ WRONG (wrong signature):
   this->decoder = [this](const std::vector<T>& chromosome) -> std::vector<std::vector<T>> {
       // NO! Wrong signature
   };

3. COMPARATOR:
   ✅ CORRECT:
   this->comparator = [](T a, T b) -> bool { return a < b; };  // Minimization
   this->comparator = [](T a, T b) -> bool { return a > b; };  // Maximization

================================================================================
COMPLETE KNAPSACK EXAMPLE (WORKING CODE)
================================================================================

This is a COMPLETE, WORKING example that follows all correct patterns:

```cpp
#ifndef KNAPSACK_CONFIG_HPP
#define KNAPSACK_CONFIG_HPP

#include "../../brkga/core/config.hpp"
#include <vector>
#include <memory>

template<typename T>
class KnapsackConfig : public BRKGAConfig<T> {
private:
    std::vector<T> weights;
    std::vector<T> values;
    T capacity;

public:
    KnapsackConfig(const std::vector<T>& w, const std::vector<T>& v, T cap)
        : BRKGAConfig<T>({static_cast<int>(w.size())}),  // CORRECT: Single component constructor
          weights(w), values(v), capacity(cap) {

        // CORRECT: Use Individual<T>& and get_chromosome()
        this->fitness_function = [this](const Individual<T>& individual) -> T {
            const auto& chromosome = individual.get_chromosome();
            T total_weight = 0;
            T total_value = 0;

            for (size_t i = 0; i < chromosome.size(); i++) {
                if (chromosome[i] > 0.5) {
                    total_weight += weights[i];
                    total_value += values[i];
                }
            }

            if (total_weight > capacity) {
                T penalty = (total_weight - capacity) * 1000;
                return total_value - penalty;
            }

            return total_value;
        };

        // CORRECT: Decoder returns std::vector<std::vector<T>>
        this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
            const auto& chromosome = individual.get_chromosome();
            std::vector<std::vector<T>> result(1);
            result[0].reserve(chromosome.size());

            for (T gene : chromosome) {
                result[0].push_back(gene > 0.5 ? T(1) : T(0));
            }

            return result;
        };

        // Maximization
        this->comparator = [](T a, T b) -> bool { return a > b; };

        this->threads_per_block = 256;
        this->update_cuda_grid_size();
    }

    void print_solution(const Individual<T>& individual) const {
        const auto& chromosome = individual.get_chromosome();
        T total_weight = 0;
        T total_value = 0;

        std::cout << "Selected items: ";
        for (size_t i = 0; i < chromosome.size(); i++) {
            if (chromosome[i] > 0.5) {
                std::cout << i << " ";
                total_weight += weights[i];
                total_value += values[i];
            }
        }
        std::cout << "\nTotal value: " << total_value;
        std::cout << "\nTotal weight: " << total_weight << "/" << capacity << "\n";
    }

    // Factory method for configs that need data files
    static std::unique_ptr<KnapsackConfig<T>> create_default() {
        std::vector<T> w = {10, 20, 30};
        std::vector<T> v = {60, 100, 120};
        T cap = 50;
        return std::make_unique<KnapsackConfig<T>>(w, v, cap);
    }
};

#endif
```

================================================================================
PROBLEM-SPECIFIC OUTPUT FORMATTING
================================================================================

CRITICAL: The print_solution() method MUST use terminology appropriate to the
problem type. DO NOT default to "tour" or "route" for non-routing problems!

Examples of problem-specific output:

ROUTING PROBLEMS (TSP, VRP):
  - Use: "Tour", "Route", "Path", "City sequence"
  - Example: "Tour: 0 -> 5 -> 12 -> 3 -> 0"

ASSIGNMENT PROBLEMS:
  - Use: "Assignment", "Allocation", "Mapping"
  - Example: "Job assignments: [2, 0, 1, 3]"

OPTIMIZATION BENCHMARKS (ZDT, DTLZ, Sphere, Rastrigin):
  - Use: "Decision variables", "Solution vector", "Variables"
  - Example: "Decision variables: x[0]=0.523, x[1]=0.891, ..."
  - DO NOT use "Tour" - these are mathematical optimization problems!

SCHEDULING PROBLEMS:
  - Use: "Schedule", "Sequence", "Order"
  - Example: "Task sequence: [T1, T3, T2, T4]"

PACKING/BIN PROBLEMS:
  - Use: "Selected items", "Packed items", "Bins"
  - Example: "Bin 1: items [2, 5, 7]"

GRAPH PROBLEMS (Coloring, Clique, etc.):
  - Use: "Colors", "Nodes", "Edges"
  - Example: "Node colors: [R, G, B, R, G]"

PORTFOLIO/FINANCIAL:
  - Use: "Allocation", "Weights", "Portfolio"
  - Example: "Asset weights: [0.3, 0.4, 0.3]"

The print_solution() method should clearly present the solution in a way
that makes sense for the specific problem domain!

================================================================================
TSP EXAMPLE PATTERN
================================================================================

For TSP problems with data files:

```cpp
template<typename T>
class TSPConfig : public BRKGAConfig<T> {
private:
    std::vector<std::vector<T>> distance_matrix;
    int num_cities;

public:
    TSPConfig(const std::string& tsp_file)
        : BRKGAConfig<T>(52) {  // For Berlin52, chromosome length = 52

        parse_tsp_file(tsp_file);
        compute_distance_matrix();

        // CORRECT signatures
        this->fitness_function = [this](const Individual<T>& individual) -> T {
            const auto& chromosome = individual.get_chromosome();
            return calculate_tour_distance(chromosome);
        };

        this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
            const auto& chromosome = individual.get_chromosome();
            return decode_to_tour(chromosome);
        };

        this->comparator = [](T a, T b) -> bool { return a < b; };  // Minimization

        this->threads_per_block = 256;
        this->update_cuda_grid_size();
    }

    // Factory method for data file loading
    static std::unique_ptr<TSPConfig<T>> create_from_file(const std::string& path) {
        return std::make_unique<TSPConfig<T>>(path);
    }
};
```

================================================================================
KEY REQUIREMENTS SUMMARY
================================================================================

1. INCLUDE PATH: Must be exactly "../../brkga/core/config.hpp"

2. BASE CLASS CONSTRUCTOR:
   - Use: BRKGAConfig<T>(length) for single component
   - Use: BRKGAConfig<T>({len1, len2, ...}) for multi-component
   - NEVER use: BRKGAConfig<T>(length, objectives, constraints)

3. FUNCTION SIGNATURES:
   - fitness_function: [this](const Individual<T>& ind) -> T
   - decoder: [this](const Individual<T>& ind) -> std::vector<std::vector<T>>
   - comparator: [](T a, T b) -> bool
   - Access chromosome: individual.get_chromosome()

4. REQUIRED METHODS:
   - print_solution(const Individual<T>& individual) const
   - MUST use problem-specific terminology (see "PROBLEM-SPECIFIC OUTPUT FORMATTING")
   - DO NOT default to "tour" for non-routing problems!

5. FACTORY METHODS:
   - For configs with hardcoded data: create_default()
   - For configs with data files: create_from_file(const std::string& path)
   - Return type: std::unique_ptr<ConfigClass<T>>

6. DECODER RETURN TYPE:
   - MUST return: std::vector<std::vector<T>>
   - First dimension: components (usually 1)
   - Second dimension: decoded values

================================================================================
ADVANCED FRAMEWORK CAPABILITIES
================================================================================

The BRKGA framework provides several advanced features for complex optimization:

1. MULTI-COMPONENT CHROMOSOMES
   - Support for problems requiring multiple decision variable groups
   - Example: TSP with Job Assignment (TSPJ) has 2 components:
     * Component 0: City sequence (permutation)
     * Component 1: Job assignments
   - Use constructor: BRKGAConfig<T>({component1_length, component2_length})

2. MULTI-OBJECTIVE OPTIMIZATION

   The framework provides TWO approaches for multi-objective problems:

   A) WEIGHTED SUM (Single Solution):
      - Use fitness_function with weighted combination of objectives
      - Returns: Single best solution
      - Example: fitness = 0.5*distance + 0.5*time
      - Use when: You want one solution with a specific tradeoff

      ```cpp
      this->fitness_function = [this](const Individual<T>& individual) -> T {
          const auto& chromosome = individual.get_chromosome();
          T obj1 = calculate_objective_1(chromosome);
          T obj2 = calculate_objective_2(chromosome);
          return 0.5 * obj1 + 0.5 * obj2;  // Weighted sum
      };
      ```

   B) NSGA-II PARETO OPTIMIZATION (Pareto Front):
      - Use objective_functions vector with separate objectives
      - Returns: Pareto front of non-dominated solutions
      - Automatically uses NSGA-II algorithm
      - Use when: You want to explore the tradeoff space

      ```cpp
      this->objective_functions.resize(NUM_OBJECTIVES);

      this->objective_functions[0] = [this](const Individual<T>& individual) -> T {
          const auto& chromosome = individual.get_chromosome();
          return objective_1_value;  // e.g., minimize distance
      };

      this->objective_functions[1] = [this](const Individual<T>& individual) -> T {
          const auto& chromosome = individual.get_chromosome();
          return objective_2_value;  // e.g., minimize time
      };
      ```

   CRITICAL DECISION RULE:
   - When objective_functions is populated → NSGA-II is AUTOMATICALLY used
   - When only fitness_function is defined → Standard BRKGA is used
   - CANNOT use both fitness_function and objective_functions together
   - Default to NSGA-II (option B) for benchmark problems (ZDT, DTLZ, etc.)
   - Use weighted sum (option A) only if user explicitly requests a single solution

3. MULTI-GPU ACCELERATION
   - Framework automatically distributes population across multiple GPUs
   - Enabled automatically when:
     * Multiple CUDA devices detected
     * Population size is large enough
     * Fitness evaluation is GPU-compatible
   - No special code required - framework handles GPU distribution
   - Provides significant speedup for large populations

4. GPU-OPTIMIZED FITNESS FUNCTIONS
   - Fitness functions run on GPU for massive parallelization
   - All lambda functions should be GPU-compatible:
     * Use standard math operations (sqrt, sin, cos, exp, log, etc.)
     * Avoid complex control flow when possible
     * Vectorizable operations are fastest
   - Framework handles memory transfer between CPU and GPU automatically

5. MULTIPLE DATA FILE SUPPORT
   - Problems can require multiple input files:

   ```cpp
   static std::unique_ptr<ConfigClass<T>> create_from_files(
       const std::string& file1_name,
       const std::string& file2_name,
       const std::string& file3_name) {
       return std::make_unique<ConfigClass<T>>(file1_name, file2_name, file3_name);
   }
   ```

   - Common patterns:
     * TSPJ: travel_time_file, job_time_file
     * VRP: distance_file, demand_file, capacity_file
     * Multi-depot routing: depot_file, customer_file

6. DATA FILE PARSING - CRITICAL RULES

NEVER make assumptions about data file dimensions or formats!

CRITICAL: NEVER hardcode chromosome length in constructor!
Use a helper method to calculate it from the file BEFORE calling base constructor.

CORRECT APPROACH:
1. Create helper method to calculate chromosome length from file
2. Call helper in base constructor initializer
3. Parse files in constructor body
4. Infer dimensions from ACTUAL parsed data
5. Validate AFTER parsing based on what was read

WRONG APPROACH:
1. ❌ Hardcode chromosome length: BRKGAConfig<T>(103)
2. ❌ Assume dimensions before parsing
3. ❌ Hardcode expected matrix sizes
4. ❌ Validate against assumed dimensions

Example showing correct pattern with helper method:

```cpp
template<typename T>
class TTPConfig : public BRKGAConfig<T> {
private:
    int num_cities;
    int num_items;

    // HELPER METHOD: Calculate chromosome length from file
    // Called BEFORE base constructor, so it must be static or use another approach
    static int calculate_chromosome_length(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + filename);
        }

        std::string line;
        int cities = 0;
        int items = 0;

        while (std::getline(file, line)) {
            if (line.find("DIMENSION:") != std::string::npos) {
                std::stringstream ss(line);
                std::string label;
                ss >> label >> cities;
            }
            else if (line.find("NUMBER OF ITEMS:") != std::string::npos) {
                std::stringstream ss(line);
                std::string dummy1, dummy2, dummy3;
                ss >> dummy1 >> dummy2 >> dummy3 >> items;
            }
        }

        file.close();
        return cities + items;  // ✅ Calculated from file!
    }

public:
    // ✅ CORRECT: Calculate chromosome length from file
    TTPConfig(const std::string& ttp_file)
        : BRKGAConfig<T>(calculate_chromosome_length(ttp_file)) {

        // Now parse full file for detailed data
        parse_ttp_file(ttp_file);

        // Dimensions were already read by helper
        // Validate they match what we calculated
        if (this->chromosome_length != num_cities + num_items) {
            throw std::runtime_error("Chromosome length mismatch");
        }

        this->fitness_function = [this](const Individual<T>& individual) -> T {
            return calculate_fitness(individual);
        };
    }

    // ❌ WRONG: Hardcoded chromosome length
    // TTPConfig(const std::string& ttp_file)
    //     : BRKGAConfig<T>(103) {  // DON'T DO THIS!
};
```

COMMON OR FILE FORMATS - Be flexible!

The system accepts ALL file types. Common OR formats include:
- .csv: Comma-separated values
- .txt: Plain text (various formats)
- .tsp, .atsp: TSP instances (TSPLIB format)
- .vrp: Vehicle routing problems
- .ttp: Traveling Thief Problem
- .dat: Generic data files
- .json: JSON format
- .sop: Sequential ordering problem
- .col: Graph coloring
- Custom formats: Many OR researchers use custom formats

PARSING STRATEGY:
1. Detect format from content (not just file extension!)
2. Handle multiple format styles:
   - CSV/TSV: parse by delimiter
   - Structured text: parse by keywords/sections
   - JSON: use JSON parser
   - Custom: parse line-by-line, infer structure
3. Be robust to whitespace, comments, headers
4. Extract data and infer problem structure

Example flexible parser:

```cpp
void parse_file(const std::string& filename, std::vector<std::vector<T>>& matrix) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open file: " + filename);
    }

    matrix.clear();
    std::string line;

    // Read line by line, infer structure
    while (std::getline(file, line)) {
        // Skip empty lines and comments
        if (line.empty() || line[0] == '#' || line[0] == '%') continue;

        std::vector<T> row;
        std::stringstream ss(line);
        std::string value;

        // Try comma-separated first
        if (line.find(',') != std::string::npos) {
            while (std::getline(ss, value, ',')) {
                value.erase(0, value.find_first_not_of(" \t"));
                value.erase(value.find_last_not_of(" \t") + 1);
                if (!value.empty()) {
                    row.push_back(static_cast<T>(std::stod(value)));
                }
            }
        } else {
            // Space/tab separated
            T val;
            while (ss >> val) {
                row.push_back(val);
            }
        }

        if (!row.empty()) {
            matrix.push_back(row);
        }
    }

    file.close();
};
```

KEY PRINCIPLE: Parse flexibly, infer structure, don't hardcode assumptions!

        // Decoder produces two components
        this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
            const auto& chromosome = individual.get_chromosome();
            std::vector<std::vector<T>> result(2);  // Two components

            // Component 0: City tour
            result[0] = decode_city_sequence(chromosome, 0, num_cities);

            // Component 1: Job assignments
            result[1] = decode_job_assignments(chromosome, num_cities, num_cities);

            return result;
        };

        this->comparator = [](T a, T b) -> bool { return a < b; };
        this->threads_per_block = 256;
        this->update_cuda_grid_size();
    }

    static std::unique_ptr<TSPJConfig<T>> create_from_files(
        const std::string& travel_time_file,
        const std::string& job_time_file) {
        return std::make_unique<TSPJConfig<T>>(travel_time_file, job_time_file);
    }
};
```

7. EXAMPLE: MULTI-OBJECTIVE PROBLEM (ZDT1 Benchmark)

```cpp
template<typename T>
class ZDT1Config : public BRKGAConfig<T> {
private:
    static constexpr int NUM_VARIABLES = 30;
    static constexpr int NUM_OBJECTIVES = 2;

public:
    ZDT1Config()
        : BRKGAConfig<T>({NUM_VARIABLES}, NUM_OBJECTIVES) {

        this->population_size = 100;
        this->max_generations = 100;

        // Multi-objective: resize and populate objective_functions
        this->objective_functions.resize(NUM_OBJECTIVES);

        // Objective 1: f1(x) = x[0]
        this->objective_functions[0] = [this](const Individual<T>& individual) -> T {
            const auto& chromosome = individual.get_chromosome();
            return chromosome[0];
        };

        // Objective 2: f2(x) = g(x) * h(f1, g)
        this->objective_functions[1] = [this](const Individual<T>& individual) -> T {
            const auto& chromosome = individual.get_chromosome();
            T f1 = chromosome[0];
            T g = calculate_g(chromosome);
            T h = 1.0 - std::sqrt(f1 / g);
            return g * h;
        };

        // Direct mapping decoder
        this->decoder = [this](const Individual<T>& individual) -> std::vector<std::vector<T>> {
            const auto& chromosome = individual.get_chromosome();
            return {chromosome};  // Single component, direct mapping
        };

        this->comparator = [](T a, T b) -> bool { return a < b; };
        this->threads_per_block = 256;
        this->update_cuda_grid_size();
    }
};
```

8. PERFORMANCE GUIDELINES

   - Population size: 100-2000 (larger for multi-objective)
   - Generations: 100-1000 for most problems
   - Multi-GPU: Best with population >= 1000
   - GPU fitness: Fastest when vectorizable
   - Avoid excessive generations (10,000+ is usually overkill)

================================================================================
END OF CONTEXT PACKAGE
================================================================================

Now generate code following these patterns exactly.
